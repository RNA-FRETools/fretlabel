{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Nucleic acid coupling chemistries\n",
    "\n",
    "This notebook implements all base-linker fragments currently available in Fluordynamics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from biopandas.mol2 import PandasMol2\n",
    "import fluordynamics as fd\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 605,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<module 'fluordynamics.ff' from '/mnt/c/Users/fsteffen/Github/fluordynamics/fluordynamics/ff.py'>"
      ]
     },
     "execution_count": 605,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import importlib\n",
    "importlib.reload(fd.ff)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "ename": "ConnectionRefusedError",
     "evalue": "[Errno 111] Connection refused",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mConnectionRefusedError\u001b[0m                    Traceback (most recent call last)",
      "\u001b[0;32m/mnt/c/Users/fsteffen/Github/fluordynamics/fluordynamics/jupyter.py\u001b[0m in \u001b[0;36mconnect2pymol\u001b[0;34m()\u001b[0m\n\u001b[1;32m     17\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m         \u001b[0mcmd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcurr_wd\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m     \u001b[0;32mexcept\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, *args)\u001b[0m\n\u001b[1;32m   1111\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__call__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1112\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__send\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1113\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36m__request\u001b[0;34m(self, methodname, params)\u001b[0m\n\u001b[1;32m   1451\u001b[0m             \u001b[0mrequest\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1452\u001b[0;31m             \u001b[0mverbose\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__verbose\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1453\u001b[0m             )\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36mrequest\u001b[0;34m(self, host, handler, request_body, verbose)\u001b[0m\n\u001b[1;32m   1153\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1154\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msingle_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhost\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandler\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mverbose\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1155\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mhttp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclient\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mRemoteDisconnected\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msingle_request\u001b[0;34m(self, host, handler, request_body, verbose)\u001b[0m\n\u001b[1;32m   1165\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1166\u001b[0;31m             \u001b[0mhttp_conn\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhost\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandler\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mverbose\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1167\u001b[0m             \u001b[0mresp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mhttp_conn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgetresponse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msend_request\u001b[0;34m(self, host, handler, request_body, debug)\u001b[0m\n\u001b[1;32m   1278\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_headers\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mconnection\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1279\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_content\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mconnection\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1280\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mconnection\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msend_content\u001b[0;34m(self, connection, request_body)\u001b[0m\n\u001b[1;32m   1308\u001b[0m         \u001b[0mconnection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mputheader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Content-Length\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1309\u001b[0;31m         \u001b[0mconnection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mendheaders\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1310\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36mendheaders\u001b[0;34m(self, message_body, encode_chunked)\u001b[0m\n\u001b[1;32m   1271\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mCannotSendHeader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1272\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_send_output\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmessage_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mencode_chunked\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mencode_chunked\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1273\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36m_send_output\u001b[0;34m(self, message_body, encode_chunked)\u001b[0m\n\u001b[1;32m   1031\u001b[0m         \u001b[0;32mdel\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_buffer\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1032\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmsg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1033\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36msend\u001b[0;34m(self, data)\u001b[0m\n\u001b[1;32m    971\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mauto_open\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 972\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconnect\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    973\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36mconnect\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    943\u001b[0m         self.sock = self._create_connection(\n\u001b[0;32m--> 944\u001b[0;31m             (self.host,self.port), self.timeout, self.source_address)\n\u001b[0m\u001b[1;32m    945\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msetsockopt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIPPROTO_TCP\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTCP_NODELAY\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/socket.py\u001b[0m in \u001b[0;36mcreate_connection\u001b[0;34m(address, timeout, source_address)\u001b[0m\n\u001b[1;32m    727\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 728\u001b[0;31m             \u001b[0;32mraise\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    729\u001b[0m         \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/socket.py\u001b[0m in \u001b[0;36mcreate_connection\u001b[0;34m(address, timeout, source_address)\u001b[0m\n\u001b[1;32m    715\u001b[0m                 \u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbind\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msource_address\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 716\u001b[0;31m             \u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconnect\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msa\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    717\u001b[0m             \u001b[0;31m# Break explicitly a reference cycle\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mConnectionRefusedError\u001b[0m: [Errno 111] Connection refused",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mConnectionRefusedError\u001b[0m                    Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-4-86e8404e6c40>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mcmd_gui\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mjupyter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconnect2pymol\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m/mnt/c/Users/fsteffen/Github/fluordynamics/fluordynamics/jupyter.py\u001b[0m in \u001b[0;36mconnect2pymol\u001b[0;34m()\u001b[0m\n\u001b[1;32m     18\u001b[0m         \u001b[0mcmd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcurr_wd\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     19\u001b[0m     \u001b[0;32mexcept\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 20\u001b[0;31m         \u001b[0mcmd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mre\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msub\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mr'/mnt/([a-z])'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34mr'\\1:'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcurr_wd\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     21\u001b[0m     \u001b[0;32mreturn\u001b[0m \u001b[0mcmd\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     22\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, *args)\u001b[0m\n\u001b[1;32m   1110\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0m_Method\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__send\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"%s.%s\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1111\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__call__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1112\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__send\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1113\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1114\u001b[0m \u001b[0;31m##\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36m__request\u001b[0;34m(self, methodname, params)\u001b[0m\n\u001b[1;32m   1450\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__handler\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1451\u001b[0m             \u001b[0mrequest\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1452\u001b[0;31m             \u001b[0mverbose\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__verbose\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1453\u001b[0m             )\n\u001b[1;32m   1454\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36mrequest\u001b[0;34m(self, host, handler, request_body, verbose)\u001b[0m\n\u001b[1;32m   1152\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m \u001b[0;32min\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1153\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1154\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msingle_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhost\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandler\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mverbose\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1155\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mhttp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclient\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mRemoteDisconnected\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1156\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0mi\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msingle_request\u001b[0;34m(self, host, handler, request_body, verbose)\u001b[0m\n\u001b[1;32m   1164\u001b[0m         \u001b[0;31m# issue XML-RPC request\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1165\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1166\u001b[0;31m             \u001b[0mhttp_conn\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_request\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhost\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandler\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mverbose\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1167\u001b[0m             \u001b[0mresp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mhttp_conn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgetresponse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1168\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mresp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstatus\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m200\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msend_request\u001b[0;34m(self, host, handler, request_body, debug)\u001b[0m\n\u001b[1;32m   1277\u001b[0m         \u001b[0mheaders\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"User-Agent\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0muser_agent\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1278\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_headers\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mconnection\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1279\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend_content\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mconnection\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1280\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mconnection\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1281\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/xmlrpc/client.py\u001b[0m in \u001b[0;36msend_content\u001b[0;34m(self, connection, request_body)\u001b[0m\n\u001b[1;32m   1307\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1308\u001b[0m         \u001b[0mconnection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mputheader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Content-Length\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1309\u001b[0;31m         \u001b[0mconnection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mendheaders\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrequest_body\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1310\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1311\u001b[0m     \u001b[0;31m##\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36mendheaders\u001b[0;34m(self, message_body, encode_chunked)\u001b[0m\n\u001b[1;32m   1270\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1271\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mCannotSendHeader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1272\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_send_output\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmessage_body\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mencode_chunked\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mencode_chunked\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1273\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1274\u001b[0m     def request(self, method, url, body=None, headers={}, *,\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36m_send_output\u001b[0;34m(self, message_body, encode_chunked)\u001b[0m\n\u001b[1;32m   1030\u001b[0m         \u001b[0mmsg\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34mb\"\\r\\n\"\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_buffer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1031\u001b[0m         \u001b[0;32mdel\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_buffer\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1032\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmsg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1033\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1034\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mmessage_body\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36msend\u001b[0;34m(self, data)\u001b[0m\n\u001b[1;32m    970\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msock\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    971\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mauto_open\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 972\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconnect\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    973\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    974\u001b[0m                 \u001b[0;32mraise\u001b[0m \u001b[0mNotConnected\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/http/client.py\u001b[0m in \u001b[0;36mconnect\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    942\u001b[0m         \u001b[0;34m\"\"\"Connect to the host and port specified in __init__.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    943\u001b[0m         self.sock = self._create_connection(\n\u001b[0;32m--> 944\u001b[0;31m             (self.host,self.port), self.timeout, self.source_address)\n\u001b[0m\u001b[1;32m    945\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msetsockopt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIPPROTO_TCP\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTCP_NODELAY\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    946\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/socket.py\u001b[0m in \u001b[0;36mcreate_connection\u001b[0;34m(address, timeout, source_address)\u001b[0m\n\u001b[1;32m    726\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0merr\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    727\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 728\u001b[0;31m             \u001b[0;32mraise\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    729\u001b[0m         \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    730\u001b[0m             \u001b[0;31m# Break explicitly a reference cycle\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/miniconda3/envs/navis/lib/python3.7/socket.py\u001b[0m in \u001b[0;36mcreate_connection\u001b[0;34m(address, timeout, source_address)\u001b[0m\n\u001b[1;32m    714\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0msource_address\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    715\u001b[0m                 \u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbind\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msource_address\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 716\u001b[0;31m             \u001b[0msock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconnect\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msa\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    717\u001b[0m             \u001b[0;31m# Break explicitly a reference cycle\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    718\u001b[0m             \u001b[0merr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mConnectionRefusedError\u001b[0m: [Errno 111] Connection refused"
     ]
    }
   ],
   "source": [
    "cmd_gui = fd.jupyter.connect2pymol()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "dyes = [('sCy3', 'C3W'), ('sCy5', 'C5W'), ('Cy7', 'C7N'), ('Cy5.5', 'C55'), ('Cy7.5','C75'), \n",
    " ('Alexa350', 'A35'), ('Alexa488', 'A48'), ('Alexa532', 'A53'), ('Alexa568', 'A56'), ('Alexa594', 'A59'), ('Alexa647', 'A64'), \n",
    " ('Atto390', 'T39'), ('Atto425', 'T42'), ('Atto465', 'T46'), ('Atto488', 'T48'), ('Atto495', 'T49'), ('Atto514', 'T51'), ('Atto520', 'T52'), ('Atto610', 'T61')]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Labeling on C5 of deoxythymidine\n",
    "\n",
    "### Geometry optimization\n",
    "\n",
    "Create Gaussian input file\n",
    "```\n",
    "name=MLE_capped\n",
    "input_folder='in/'\n",
    "output_folder='out/'\n",
    "\n",
    "antechamber -i \"$input_folder/$name\".mol2 -fi mol2 -o \"$output_folder/$name\".gin -fo gcrt -gv 1 -ge \"$output_folder/$name\".gesp -ch \"$output_folder/$name\"_opt -nc 0\n",
    "```\n",
    "\n",
    "Gaussian geometry optimization and ESP calculation\n",
    "```\n",
    "nproc=12\n",
    "\n",
    "sed 's/#HF.*/\\#P b3lyp\\/6-31G\\* Opt/g' < \"$output_folder/$name\".gin | sed '/iop/d' | sed '/.*gesp/d' | sed \"/--Link1--/ a %nproc=$nproc\" > \"$output_folder/$name\"_b3lyp_opt.gin\n",
    "\n",
    "sed '/^[[:space:]]*[A-Z]/d' < \"$output_folder/$name\".gin | sed 's/SCF/Geom=check SCF/g'| sed 's/\\(\\%chk=.*\\)opt/\\1esp/g' | sed \"/--Link1--/ a %nproc=$nproc\" > \"$output_folder/$name\"_hf_esp.gin\n",
    "\n",
    "g09 < \"$output_folder/$name\"_b3lyp_opt.gin > \"$output_folder/$name\"_b3lyp_opt.gout && cp \"$output_folder/$name\"_opt.chk \"$output_folder/$name\"_esp.chk\n",
    "```\n",
    "> **Note:** Make sure that charge and multiplicity are compatible (check log files in case of segmentation errors) files\n",
    "\n",
    "```\n",
    "g09 < \"$output_folder/$name\"_hf_esp.gin > \"$output_folder/$name\"_hf_esp.gout\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Partial charge fitting with RESP\n",
    "\n",
    "```\n",
    "antechamber -i \"$input_folder/$name\".mol2 -fi mol2 -o \"$output_folder/$name\".ac -fo ac -pf yes -nc 0\n",
    "\n",
    "capping_group=MLE_capping_groups.dat\n",
    "\n",
    "n_atom=`awk '$1 == \"GROUP\" {print $2}' \"$input_folder/$capping_group\"`\n",
    "group_constraint=`awk '$1 == \"GROUP\" {print $3}' \"$input_folder/$capping_group\"`\n",
    "\n",
    "respgen -i \"$output_folder/$name\".ac -o \"$output_folder/$name\".respin1 -f resp1 -a \"$input_folder/$capping_group\"\n",
    "respgen -i \"$output_folder/$name\".ac -o \"$output_folder/$name\".respin2 -f resp2 -a \"$input_folder/$capping_group\"\n",
    "\n",
    "# since respgen rounds the group constraint to three decimals replace it with the value from the capping group\n",
    "for i in `seq $(echo $n_atom | wc -w)`;do\n",
    "    atom=`echo $n_atom | cut -f$i -d' '`\n",
    "    group=`echo $group_constraint | cut -f$i -d' '`\n",
    "    sed -z -i \"s/$atom\\s*-*\\w\\.\\w*$p/$atom  $group/$i\" \"$output_folder/$name\".respin1\n",
    "    sed -z -i \"s/$atom\\s*-*\\w\\.\\w*$p/$atom  $group/$i\" \"$output_folder/$name\".respin2\n",
    "done\n",
    "\n",
    "espgen -i \"$output_folder/$name\"_hf_esp.gout -o \"$output_folder/$name\"_hf_esp.esp\n",
    "mv QIN \"$output_folder\"/\n",
    "\n",
    "resp -O -i \"$output_folder/$name\".respin1 -o \"$output_folder/$name\".respout1 -e \"$output_folder/$name\"_hf_esp.esp -q  \"$output_folder\"/QIN -t \"$output_folder\"/qout_stage1 -p \"$output_folder\"/punch1 -s \"$output_folder\"/esout1\n",
    "resp -O -i \"$output_folder/$name\".respin2 -o \"$output_folder/$name\".respout2 -e \"$output_folder/$name\"_hf_esp.esp -q \"$output_folder\"/qout_stage1 -t \"$output_folder\"/qout_stage2 -p \"$output_folder\"/punch2 -s \"$output_folder\"/esout2\n",
    "\n",
    "antechamber -i \"$output_folder/$name\".ac -fi ac -o \"$output_folder/$name\"_resp.mol2 -fo mol2 -c rc -cf \"$output_folder\"/qout_stage2 -pf yes -at amber\n",
    "```\n",
    "\n",
    "**Hint:** The above two-stage RESP fitting protocol is wrapped in the following script:\n",
    "```\n",
    "resp_fit.sh -n MLE_capped -i 'in/' -o 'out/' -g MLE_capping_groups.dat -c 0\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Coupling to base and dye\n",
    "First couple the deoxythymine base and the MLE linker"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "cmd_gui.load('../fragments/linkers/MLE/out/MLE_capped_resp.mol2')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "names_methylene = ['C7','H01','H02']\n",
    "\n",
    "#base_resn = ('deoxythymidine', 'DTM')\n",
    "base_resn = ('oxythymidine', 'RUM')\n",
    "\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/bases/out/{}.mol2'.format(base_resn[0]))\n",
    "cmd_gui.load('../fragments/linkers/MLE/out/MLE_capped_resp.mol2')\n",
    "cmd_gui.remove('MLE_capped_resp and name {}'.format('+'.join(str(i) for i in names_methylene)))\n",
    "cmd_gui.remove('{} and (name H71 or name H72)'.format(base_resn[0]))\n",
    "cmd_gui.fuse('{} and name C7'.format(base_resn[0]), 'MLE_capped_resp and name C8 and resn MLE')\n",
    "cmd_gui.delete('{}'.format(base_resn[0]))\n",
    "cmd_gui.alter('all', 'type=\"ATOM\"')\n",
    "cmd_gui.alter('all', 'elem=\"\"') # PyMOL struggles with atom type definitions in mol2 files, therefore let PyMOL guess the elements itself\n",
    "cmd_gui.set_name('MLE_capped_resp', base_resn[1])\n",
    "cmd_gui.set_title('MLE',1,base_resn[1])\n",
    "cmd_gui.unbond('resn {} and name C8'.format(base_resn[1]), 'resn DT and name C7')\n",
    "cmd_gui.bond('resn {} and name C8'.format(base_resn[1]), 'resn DT and name C7', 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), base_resn[1], overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Check passed!\n"
     ]
    }
   ],
   "source": [
    "fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, add the fluorophore"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "base_resn_list = [('deoxythymidine', 'DTM'),\n",
    "                  ('oxythymidine', 'RUM')]\n",
    "for base_resn in base_resn_list:\n",
    "\n",
    "    for name,dye in dyes:\n",
    "        fd.ff.couple_dye2baselinker(dye, base_resn[1], 'C99', ['C17', 'O98', 'C16'], ['O98', 'C16', 'C17', 'H95', 'H96', 'H97'])\n",
    "        cmd_gui.alter('all', 'elem=\"\"')\n",
    "        fd.ff.save_molecule('../fluorlabel/dyes/{}_{}.pdb'.format(dye, base_resn[1]), '{}_{}'.format(dye, base_resn[1]), 'pdb', overwrite=True)\n",
    "        #fd.ff.update_dye_library({'filename':'{}_DTM'.format(dye), 'dye':name, 'base':'RU+DT', 'linker':'MLE', 'chemistry':'dT-C5', 'position':'internal'}, '../fluorlabel/dyes/dye_library.json', '../fluorlabel/dyes/dye_library.json', overwrite=True)\n",
    "        fd.ff.update_dye_library({'filename':'{}_{}'.format(dye, base_resn[1]), 'dye':name, 'base':base_resn[1][0:2], 'linker':'MLE', 'chemistry':'U/dT-C5', 'position':'internal'}, '../fluorlabel/dye_library.json', '../fluorlabel/dye_library.json', overwrite=True)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Labeling via phosphate at 5'-end\n",
    "\n",
    "### Geometry optimization\n",
    "\n",
    "Create Gaussian input file\n",
    "```\n",
    "name=POS_capped\n",
    "input_folder='in/'\n",
    "output_folder='out/'\n",
    "```\n",
    "\n",
    "Here, the net charge is -1\n",
    "```\n",
    "antechamber -i \"$input_folder/$name\".mol2 -fi mol2 -o \"$output_folder/$name\".gin -fo gcrt -gv 1 -ge \"$output_folder/$name\".gesp -ch \"$output_folder/$name\"_opt -nc -1\n",
    "```\n",
    "\n",
    "Gaussian geometry optimization and ESP calculation\n",
    "```\n",
    "nproc=12\n",
    "\n",
    "sed 's/#HF.*/\\#P b3lyp\\/6-31G\\* Opt/g' < \"$output_folder/$name\".gin | sed '/iop/d' | sed '/.*gesp/d' | sed \"/--Link1--/ a %nproc=$nproc\" > \"$output_folder/$name\"_b3lyp_opt.gin\n",
    "\n",
    "sed '/^[[:space:]]*[A-Z]/d' < \"$output_folder/$name\".gin | sed 's/SCF/Geom=check SCF/g'| sed 's/\\(\\%chk=.*\\)opt/\\1esp/g' | sed \"/--Link1--/ a %nproc=$nproc\" > \"$output_folder/$name\"_hf_esp.gin\n",
    "\n",
    "g09 < \"$output_folder/$name\"_b3lyp_opt.gin > \"$output_folder/$name\"_b3lyp_opt.gout && cp \"$output_folder/$name\"_opt.chk \"$output_folder/$name\"_esp.chk\n",
    "```\n",
    "> **Note:** Make sure that charge and multiplicity are compatible (check log files in case of segmentation errors) files\n",
    "\n",
    "```\n",
    "g09 < \"$output_folder/$name\"_hf_esp.gin > \"$output_folder/$name\"_hf_esp.gout\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Partial charge fitting with RESP\n",
    "\n",
    "Run Antechamber with net charge -1\n",
    "```\n",
    "antechamber -i \"$input_folder/$name\".mol2 -fi mol2 -o \"$output_folder/$name\".ac -fo ac -pf yes -nc -1\n",
    "\n",
    "capping_group=POS_capping_groups_5prime_DNA.dat\n",
    "\n",
    "n_atom=`awk '$1 == \"GROUP\" {print $2}' \"$input_folder/$capping_group\"`\n",
    "group_constraint=`awk '$1 == \"GROUP\" {print $3}' \"$input_folder/$capping_group\"`\n",
    "\n",
    "respgen -i \"$output_folder/$name\".ac -o \"$output_folder/$name\".respin1 -f resp1 -a \"$input_folder/$capping_group\"\n",
    "respgen -i \"$output_folder/$name\".ac -o \"$output_folder/$name\".respin2 -f resp2 -a \"$input_folder/$capping_group\"\n",
    "\n",
    "# since respgen rounds the group constraint to three decimals replace it with the value from the capping group\n",
    "for i in `seq $(echo $n_atom | wc -w)`;do\n",
    "    atom=`echo $n_atom | cut -f$i -d' '`\n",
    "    group=`echo $group_constraint | cut -f$i -d' '`\n",
    "    sed -z -i \"s/$atom\\s*-*\\w\\.\\w*$p/$atom  $group/$i\" \"$output_folder/$name\".respin1\n",
    "    sed -z -i \"s/$atom\\s*-*\\w\\.\\w*$p/$atom  $group/$i\" \"$output_folder/$name\".respin2\n",
    "done\n",
    "\n",
    "espgen -i \"$output_folder/$name\"_hf_esp.gout -o \"$output_folder/$name\"_hf_esp.esp\n",
    "mv QIN \"$output_folder\"/\n",
    "\n",
    "resp -O -i \"$output_folder/$name\".respin1 -o \"$output_folder/$name\".respout1 -e \"$output_folder/$name\"_hf_esp.esp -q  \"$output_folder\"/QIN -t \"$output_folder\"/qout_stage1 -p \"$output_folder\"/punch1 -s \"$output_folder\"/esout1\n",
    "resp -O -i \"$output_folder/$name\".respin2 -o \"$output_folder/$name\".respout2 -e \"$output_folder/$name\"_hf_esp.esp -q \"$output_folder\"/qout_stage1 -t \"$output_folder\"/qout_stage2 -p \"$output_folder\"/punch2 -s \"$output_folder\"/esout2\n",
    "\n",
    "antechamber -i \"$output_folder/$name\".ac -fi ac -o \"$output_folder/$name\"_resp.mol2 -fo mol2 -c rc -cf \"$output_folder\"/qout_stage2 -pf yes -at amber\n",
    "```\n",
    "\n",
    "**Hint:** The above two-stage RESP fitting protocol is wrapped in the following script:\n",
    "```\n",
    "resp_fit.sh -n POS_capped -i 'in/' -o 'out/' -g POS_capping_groups_5prime_DNA.dat -c -1\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Coupling of base and dye\n",
    "Again, first couple the bases and the POS linker"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 532,
   "metadata": {},
   "outputs": [],
   "source": [
    "names_methyl = ['C01','H01','H02','H03']\n",
    "names_phosphate = ['P','O1P','O5\\'','O2P']\n",
    "\n",
    "\n",
    "base_resn = ('deoxythymidine', 'DTP')\n",
    "# base_resn = ('deoxyadenosine', 'DAP')\n",
    "# base_resn = ('deoxyguanosine', 'DGP')\n",
    "# base_resn = ('deoxycytidine', 'DCP')\n",
    "# base_resn = ('uridine', 'RUP')\n",
    "# base_resn = ('adenosine', 'RAP')\n",
    "# base_resn = ('guanosine', 'RGP')\n",
    "# base_resn = ('cytidine', 'RCP')\n",
    "\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/bases/out/{}.mol2'.format(base_resn[0]))\n",
    "\n",
    "if 'D' in base_resn[1]:\n",
    "    POS_capped_resp = 'POS_capped_resp_5prime_DNA'\n",
    "else:\n",
    "    POS_capped_resp = 'POS_capped_resp_5prime_RNA'\n",
    "    \n",
    "cmd_gui.load('../fragments/linkers/POS/out/{}.mol2'.format(POS_capped_resp))\n",
    "cmd_gui.align('{} and name {}'.format(POS_capped_resp, '+'.join(str(i) for i in names_phosphate)), '{} and (name P or name O1P or name O2P or name O5\\')'.format(base_resn[0]))\n",
    "cmd_gui.remove('{} and name {}'.format(POS_capped_resp, '+'.join(str(i) for i in names_methyl+names_phosphate)))\n",
    "cmd_gui.create(base_resn[1], '{} or {}'.format(POS_capped_resp, base_resn[0]))\n",
    "cmd_gui.delete(base_resn[0])\n",
    "cmd_gui.delete(POS_capped_resp)\n",
    "cmd_gui.bond('{} and name P'.format(base_resn[1]), '{} and name O01'.format(base_resn[1]))\n",
    "cmd_gui.alter('all', 'type=\"ATOM\"')\n",
    "cmd_gui.alter('all', 'elem=\"\"')\n",
    "cmd_gui.set_title(base_resn[1],1,base_resn[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 533,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), base_resn[1], overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 534,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Check passed!\n"
     ]
    }
   ],
   "source": [
    "if 'D' in base_resn[1]:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1.3079)\n",
    "else:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1.3081)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then add the fluorophore"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "base_resn_list = [('deoxythymidine', 'DTP'), \n",
    "                  ('deoxyadenosine', 'DAP'),\n",
    "                  ('deoxyguanosine', 'DGP'),\n",
    "                  ('deoxycytidine', 'DCP'),\n",
    "                  ('uridine', 'RUP'),\n",
    "                  ('adenosine', 'RAP'),\n",
    "                  ('guanosine', 'RGP'),\n",
    "                  ('cytidine', 'RCP')]\n",
    "\n",
    "for base_resn in base_resn_list:\n",
    "\n",
    "    for name, dye in dyes:\n",
    "        fd.ff.couple_dye2baselinker(dye, base_resn[1], 'C99', ['C17', 'O98', 'C16'], ['O98', 'C16', 'C17', 'H95', 'H96', 'H97'])\n",
    "        cmd_gui.alter('all', 'elem=\"\"')\n",
    "        fd.ff.save_molecule('../fluorlabel/dyes/{}_{}.pdb'.format(dye, base_resn[1]), '{}_{}'.format(dye, base_resn[1]), 'pdb', overwrite=True)\n",
    "        for base in ['RA', 'RG', 'RC', 'RU', 'DA', 'DG', 'DC', 'DT']:\n",
    "            fd.ff.update_dye_library({'filename':'{}_{}P'.format(dye, base), 'dye':name, 'base':base, 'linker':'POS', 'chemistry':'phosphate', 'position':\"5'-end\"}, '../fluorlabel/dye_library.json', '../fluorlabel/dye_library.json', overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Labeling via phosphate at 3'-end\n",
    "\n",
    "Same as for 5'-end. For RESP use instead:\n",
    "```\n",
    "resp_fit.sh -n POS_capped -i 'in/' -o 'out/' -g POS_capping_groups_3prime_DNA.dat -c -1\n",
    "resp_fit.sh -n POS_capped -i 'in/' -o 'out/' -g POS_capping_groups_3prime_RNA.dat -c -1\n",
    "```\n",
    "\n",
    "First couple the bases and the POS linker, then add the dye."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 584,
   "metadata": {},
   "outputs": [],
   "source": [
    "names_methyl = ['C01','H01','H02','H03']\n",
    "\n",
    "base_resn = ('deoxythymidine', 'DTO')\n",
    "# base_resn = ('deoxyadenosine', 'DAO')\n",
    "# base_resn = ('deoxyguanosine', 'DGO')\n",
    "# base_resn = ('deoxycytidine', 'DCO')\n",
    "# base_resn = ('uridine', 'RUO')\n",
    "# base_resn = ('adenosine', 'RAO')\n",
    "# base_resn = ('guanosine', 'RGO')\n",
    "# base_resn = ('cytidine', 'RCO')\n",
    "\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/bases/out/{}.mol2'.format(base_resn[0]))\n",
    "\n",
    "if 'D' in base_resn[1]:\n",
    "    POS_capped_resp = 'POS_capped_resp_3prime_DNA'\n",
    "else:\n",
    "    POS_capped_resp = 'POS_capped_resp_3prime_RNA'\n",
    "    \n",
    "cmd_gui.load('../fragments/linkers/POS/out/{}.mol2'.format(POS_capped_resp))\n",
    "cmd_gui.alter('{} and name P'.format(POS_capped_resp),'name=\"P1\"')\n",
    "cmd_gui.alter('{} and name O1P'.format(POS_capped_resp),'name=\"O3P\"')\n",
    "cmd_gui.alter('{} and name O2P'.format(POS_capped_resp),'name=\"O4P\"')\n",
    "cmd_gui.pair_fit('{} and name O5\\''.format(POS_capped_resp),'{} and name O3\\''.format(base_resn[0]), \n",
    "                 '{} and name C01'.format(POS_capped_resp), '{} and name C3\\''.format(base_resn[0]), \n",
    "                 '{} and name H03'.format(POS_capped_resp), '{} and name H3\\''.format(base_resn[0]))\n",
    "cmd_gui.remove('{} and (name {} or name O5\\')'.format(POS_capped_resp, '+'.join(str(i) for i in names_methyl)))\n",
    "cmd_gui.create(base_resn[1], '{} or {}'.format(POS_capped_resp, base_resn[0]))\n",
    "cmd_gui.delete(base_resn[0])\n",
    "cmd_gui.delete(POS_capped_resp)\n",
    "cmd_gui.bond('{} and name P1 and resn POS'.format(base_resn[1]), '{} and name O3\\''.format(base_resn[1]))\n",
    "cmd_gui.alter('all', 'type=\"ATOM\"')\n",
    "cmd_gui.alter('all', 'elem=\"\"')\n",
    "cmd_gui.set_title(base_resn[1],1,base_resn[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 585,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), base_resn[1], overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 586,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Check passed!\n"
     ]
    }
   ],
   "source": [
    "if 'D' in base_resn[1]:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1.6921)\n",
    "else:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1.6919)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "base_resn_list = [('deoxythymidine', 'DTO'),\n",
    "                  ('deoxyadenosine', 'DAO'),\n",
    "                  ('deoxyguanosine', 'DGO'),\n",
    "                  ('deoxycytidine', 'DCO'),\n",
    "                  ('uridine', 'RUO'),\n",
    "                  ('adenosine', 'RAO'),\n",
    "                  ('guanosine', 'RGO'),\n",
    "                  ('cytidine', 'RCO')]\n",
    "\n",
    "for base_resn in base_resn_list:\n",
    "\n",
    "    for name, dye in dyes:\n",
    "        fd.ff.couple_dye2baselinker(dye, base_resn[1], 'C99', ['C17', 'O98', 'C16'], ['O98', 'C16', 'C17', 'H95', 'H96', 'H97'])\n",
    "        cmd_gui.alter('all', 'elem=\"\"')\n",
    "        fd.ff.save_molecule('../fluorlabel/dyes/{}_{}.pdb'.format(dye, base_resn[1]), '{}_{}'.format(dye, base_resn[1]), 'pdb', overwrite=True)\n",
    "        for base in ['RA', 'RG', 'RC', 'RU', 'DA', 'DG', 'DC', 'DT']:\n",
    "            fd.ff.update_dye_library({'filename':'{}_{}O'.format(dye, base), 'dye':name, 'base':base, 'linker':'POS', 'chemistry':'phosphate', 'position':\"3'-end\"}, '../fluorlabel/dye_library.json', '../fluorlabel/dye_library.json', overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Internal labeling via ethenoadenine or ethenocytosine\n",
    "\n",
    "### Geometry optimization\n",
    "\n",
    "Same as for deoxythymine (MLE) but with `name=ETH_capped`\n",
    "\n",
    "### Partial charge fitting with RESP\n",
    "\n",
    "In general the same as for deoxythymine (MLE). For RESP use:\n",
    "\n",
    "```\n",
    "resp_fit.sh -n ETH_capped -i 'in/' -o 'out/' -g ETH_capping_groups_adenine_DNA.dat -c 0\n",
    "resp_fit.sh -n ETH_capped -i 'in/' -o 'out/' -g ETH_capping_groups_cytosine_DNA.dat -c 0\n",
    "resp_fit.sh -n ETH_capped -i 'in/' -o 'out/' -g ETH_capping_groups_adenine_RNA.dat -c 0\n",
    "resp_fit.sh -n ETH_capped -i 'in/' -o 'out/' -g ETH_capping_groups_cytosine_RNA.dat -c 0\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "names_amine = ['N1','N6','H11','H12','H61','H62']\n",
    "\n",
    "base_resn = ('deoxyadenosine', 'DAE')\n",
    "#base_resn = ('deoxycytidine', 'DCE')\n",
    "#base_resn = ('adenosine', 'RAE')\n",
    "#base_resn = ('cytidine', 'RCE')\n",
    "\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/bases/out/{}.mol2'.format(base_resn[0]))\n",
    "\n",
    "if 'A' in base_resn[1]:\n",
    "    cmd_gui.load('../fragments/linkers/ETH/out/ETH_capped_resp_{}.mol2'.format(base_resn[0]))\n",
    "    cmd_gui.pair_fit('ETH_capped_resp and name N1','{} and name N1'.format(base_resn[0]), \n",
    "                 'ETH_capped_resp and name N6', '{} and name N6'.format(base_resn[0]),\n",
    "                 'ETH_capped_resp and name H11', '{} and name C2'.format(base_resn[0]))\n",
    "else:\n",
    "    cmd_gui.load('../fragments/linkers/ETH/out/ETH_capped_resp_{}.mol2'.format(base_resn[0]))\n",
    "    cmd_gui.pair_fit('ETH_capped_resp and name N1','{} and name N3'.format(base_resn[0]), \n",
    "                 'ETH_capped_resp and name N6', '{} and name N4'.format(base_resn[0]),\n",
    "                 'ETH_capped_resp and name H11', '{} and name C2'.format(base_resn[0]))\n",
    "    \n",
    "cmd_gui.remove('ETH_capped_resp and name {}'.format('+'.join(str(i) for i in names_amine)))\n",
    "if 'A' in base_resn[1]:\n",
    "    cmd_gui.remove('{} and (name H61 or name H62)'.format(base_resn[0]))\n",
    "    cmd_gui.remove('{} and name H61'.format(base_resn[0]))\n",
    "    cmd_gui.unbond('{} and name C6'.format(base_resn[0]), '{} and name N6'.format(base_resn[0]))\n",
    "    cmd_gui.bond('{} and name C6'.format(base_resn[0]), '{} and name N6'.format(base_resn[0]), 2)\n",
    "    cmd_gui.unbond('{} and name C6'.format(base_resn[0]), '{} and name N1'.format(base_resn[0]))\n",
    "    cmd_gui.bond('{} and name C6'.format(base_resn[0]), '{} and name N1'.format(base_resn[0]), 1)\n",
    "else:\n",
    "    cmd_gui.remove('{} and (name H41 or name H42)'.format(base_resn[0]))\n",
    "    cmd_gui.unbond('{} and name C4'.format(base_resn[0]), '{} and name N4'.format(base_resn[0]))\n",
    "    cmd_gui.bond('{} and name C4'.format(base_resn[0]), '{} and name N4'.format(base_resn[0]), 2)\n",
    "    cmd_gui.unbond('{} and name C4'.format(base_resn[0]), '{} and name N3'.format(base_resn[0]))\n",
    "    cmd_gui.bond('{} and name C4'.format(base_resn[0]), '{} and name N3'.format(base_resn[0]), 1)\n",
    "    \n",
    "cmd_gui.create(base_resn[1], 'ETH_capped or {}'.format(base_resn[0]))\n",
    "cmd_gui.delete(base_resn[0])\n",
    "cmd_gui.delete('ETH_capped')\n",
    "\n",
    "if 'A' in base_resn[1]:\n",
    "    cmd_gui.bond('{} and name N1'.format(base_resn[1]), '{} and name C9'.format(base_resn[1]))\n",
    "    cmd_gui.bond('{} and name N6'.format(base_resn[1]), '{} and name C7'.format(base_resn[1]))\n",
    "else:\n",
    "    cmd_gui.bond('{} and name N3'.format(base_resn[1]), '{} and name C9'.format(base_resn[1]))\n",
    "    cmd_gui.bond('{} and name N4'.format(base_resn[1]), '{} and name C7'.format(base_resn[1]))\n",
    "    \n",
    "cmd_gui.alter('all', 'type=\"ATOM\"')\n",
    "cmd_gui.alter('all', 'elem=\"\"')\n",
    "cmd_gui.set_title(base_resn[1],1,base_resn[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), base_resn[1], overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Check passed!\n"
     ]
    }
   ],
   "source": [
    "fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "base_resn_list = [('deoxyadenosine', 'DAE'),\n",
    "                  ('deoxycytidine', 'DCE'),\n",
    "                  ('adenosine', 'RAE'),\n",
    "                  ('cytidine', 'RCE')]\n",
    "\n",
    "for base_resn in base_resn_list:\n",
    "\n",
    "    for name, dye in dyes:\n",
    "        fd.ff.couple_dye2baselinker(dye, base_resn[1], 'C99', ['C17', 'O98', 'C16'], ['O98', 'C16', 'C17', 'H95', 'H96', 'H97'])\n",
    "        cmd_gui.alter('all', 'elem=\"\"')\n",
    "        fd.ff.save_molecule('../fluorlabel/dyes/{}_{}.pdb'.format(dye, base_resn[1]), '{}_{}'.format(dye, base_resn[1]), 'pdb', overwrite=True)\n",
    "        for base in ['RA', 'RC', 'DA', 'DC']:    \n",
    "            fd.ff.update_dye_library({'filename':'{}_{}E'.format(dye, base), 'dye':name, 'base':base, 'linker':'ETH', 'chemistry':'etheno', 'position':'internal'}, '../fluorlabel/dye_library.json', '../fluorlabel/dye_library.json', overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Labeling via hydrazide at 3'-end\n",
    "\n",
    "### Geometry optimization\n",
    "Same as for phosphate (POS) but with `name=HYD_capped`\n",
    "\n",
    "### Partial charge fitting with RESP\n",
    "In general the same as for phosphate (POS). For RESP use:\n",
    "\n",
    "```\n",
    "resp_fit.sh -n HYD_capped -i 'in/' -o 'out/' -g HYD_capping_groups_adenine_RNA.dat -c -1\n",
    "resp_fit.sh -n HYD_capped -i 'in/' -o 'out/' -g HYD_capping_groups_guanine_RNA.dat -c -1\n",
    "resp_fit.sh -n HYD_capped -i 'in/' -o 'out/' -g HYD_capping_groups_cytosine_RNA.dat -c -1\n",
    "resp_fit.sh -n HYD_capped -i 'in/' -o 'out/' -g HYD_capping_groups_uracil_RNA.dat -c -1\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 616,
   "metadata": {},
   "outputs": [],
   "source": [
    "names_methoxyl = ['C01','H01','H02','H03', 'O01']\n",
    "names_amine = ['N97','H94','H93']\n",
    "\n",
    "# only RNA residues because labeling needs O2' and O3' to form a dialdehyde\n",
    "base_resn = ('uridine', 'RUH')\n",
    "base_resn = ('adenosine', 'RAH')\n",
    "base_resn = ('guanosine', 'RGH')\n",
    "base_resn = ('cytidine', 'RCH')\n",
    "\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/bases/out/{}.mol2'.format(base_resn[0]))\n",
    "cmd_gui.load('../fragments/linkers/HYD/out/HYD_capped_resp_{}_RNA.mol2'.format(base_resn[0]))\n",
    "\n",
    "if ('A' in base_resn[1]) or ('G' in base_resn[1]):\n",
    "    atm = 'N9'\n",
    "else:\n",
    "    atm = 'N1'\n",
    "\n",
    "cmd_gui.pair_fit('HYD_capped and name O5\\'','{} and name O5\\''.format(base_resn[0]), \n",
    "                 'HYD_capped and name C5\\'', '{} and name C5\\''.format(base_resn[0]), \n",
    "                 'HYD_capped and name P', '{} and name P'.format(base_resn[0]),\n",
    "                 'HYD_capped and name C4\\'', '{} and name C4\\''.format(base_resn[0]),\n",
    "                 'HYD_capped and name O4\\'', '{} and name O4\\''.format(base_resn[0]),\n",
    "                 'HYD_capped and name N97', '{} and name {}'.format(base_resn[0], atm))\n",
    "cmd_gui.remove('HYD_capped_resp and name {}'.format('+'.join(str(i) for i in names_methoxyl)))\n",
    "cmd_gui.remove('HYD_capped_resp and name {}'.format('+'.join(str(i) for i in names_amine)))\n",
    "cmd_gui.remove('{} and name {}'.format(base_resn[0], 'C*\\'+O*\\'+O*P*+H*\\'*+P'))\n",
    "cmd_gui.create(base_resn[1], 'HYD_capped_resp or {}'.format(base_resn[0]))\n",
    "cmd_gui.delete(base_resn[0])\n",
    "cmd_gui.delete('HYD_capped_resp')\n",
    "cmd_gui.bond('{} and name {}'.format(base_resn[1], atm), '{} and name C1\\''.format(base_resn[1]))\n",
    "cmd_gui.set_title(base_resn[1],1,base_resn[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 617,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), base_resn[1], overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 618,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Check passed!\n"
     ]
    }
   ],
   "source": [
    "if 'D' in base_resn[1]:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -0.6921)\n",
    "else:\n",
    "    fd.ff.check_charge('../fragments/base_linkers/{}.mol2'.format(base_resn[1]), -0.6919)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "base_resn_list = [('uridine', 'RUH'),\n",
    "                  ('adenosine', 'RAH'),\n",
    "                  ('guanosine', 'RGH'),\n",
    "                  ('cytidine', 'RCH')]\n",
    "\n",
    "for base_resn in base_resn_list:\n",
    "\n",
    "    for name, dye in dyes:\n",
    "        fd.ff.couple_dye2baselinker(dye, base_resn[1], 'C99', ['C17', 'O98', 'C16'], ['O98', 'C16', 'C17', 'H95', 'H96', 'H97'])\n",
    "        cmd_gui.alter('all', 'elem=\"\"')\n",
    "        fd.ff.save_molecule('../fluorlabel/dyes/{}_{}.pdb'.format(dye, base_resn[1]), '{}_{}'.format(dye, base_resn[1]), 'pdb', overwrite=True)\n",
    "        for base in ['RA', 'RG', 'RC', 'RU']:    \n",
    "            fd.ff.update_dye_library({'filename':'{}_{}H'.format(dye, base), 'dye':name, 'base':base, 'linker':'HYD', 'chemistry':'hydrazide', 'position':\"3'-end\"}, '../fluorlabel/dye_library.json', '../fluorlabel/dye_library.json', overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Forcefield parameterization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, read in AMBERDYES force field (Graen et al. *JCTC*, **2014**)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 606,
   "metadata": {},
   "outputs": [],
   "source": [
    "amberdyes_ff = fd.ff.Parameters.read_amberdyes(['../../../fluordynamics/forcefields/amberdyes/ffbonded_amberdyes.itp', '../../../fluordynamics/forcefields/amberdyes/ffnonbonded_amberdyes.itp'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 607,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "aber14sb_ff = fd.ff.Parameters.read_ff(['ff14sb/ffbonded.itp', 'ff14sb/ffnonbonded.itp'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Run **Acpype** on the internal DTM fragment"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```\n",
    "cd ../fragments/acpype\n",
    "\n",
    "base_linker=DTM\n",
    "base=DT\n",
    "\n",
    "base_linker=RUM\n",
    "base=RU\n",
    "\n",
    "linker=MLE\n",
    "filename=../base_linkers/\"$base_linker\".mol2\n",
    "sed \"s/${base}/${base_linker}/g\" \"$filename\" | sed \"s/${linker}/${base_linker}/g\" > \"$base_linker\"_ff.mol2\n",
    "acpype -i \"$base_linker\"_ff.mol2 -o gmx -n -1 -a amber -c user\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 608,
   "metadata": {},
   "outputs": [],
   "source": [
    "baselinkers_itp = {}\n",
    "baselinkers_ff = {}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Read the itp files into the `fd.ff.Molecule` class and the forcefield modification parameters into the `fd.ff.Parameters` class."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 609,
   "metadata": {},
   "outputs": [],
   "source": [
    "moleculetypes = ['DTM', 'RUM']\n",
    "\n",
    "for mol in moleculetypes:\n",
    "    baselinkers_itp[mol] = fd.ff.Molecule.read_molecule('../../../fluordynamics/fragments/acpype/{}_ff.acpype/{}_ff_GMX.itp'.format(mol,mol), 'FLUOR-DYNAMICS')\n",
    "    baselinkers_itp[mol].change_type('O3\\'', 'OS') # residue is internal not terminal\n",
    "    for a in ['O98', 'C16', 'C17', 'H95', 'H96', 'H97']:\n",
    "        baselinkers_itp[mol].remove_atom(a)\n",
    "    baselinkers_ff[mol] = fd.ff.Parameters.read_frcmod('../../../fluordynamics/fragments/acpype/{}_ff.acpype/{}_ff_AC.frcmod'.format(mol,mol), baselinkers_itp[mol].atomtypes_molecule)\n",
    "    amberdyes_ff.append(baselinkers_ff[mol])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Rational for linker RESP charge derivation at 3'/5'-ends via phosphate\n",
    "\n",
    "Reference: https://ambermd.org/tutorials/advanced/tutorial1/section1.htm\n",
    "\n",
    "In the AMBER force fields (Cornell, *JACS*, **1995**) the **DNA** nucleotides the charges at the termini is as follows:\n",
    "- 5'-end nucleotide: -0.3079\n",
    "- 3'-end nucleotide: -0.6921\n",
    "\n",
    "For **RNA** the charges are:\n",
    "- 5'-end nucleotide: -0.3081\n",
    "- 3'-end nucleotide: -0.6919\n",
    "\n",
    "<img src='images/DNAparameters_Cornell1995.png' width=800>\n",
    "\n",
    "#### Labeled DNA 5'-terminus \n",
    "The 5'-end nucleotide will become an internal residue (DNA charge: -1; i.e. the phosphate of the linker will be transferred to this nucleotide). The linker will become the new 5'-terminus (DNA charge: -0.3079). For this purpose, the **methylphosphate cap** ($-PO_2-OCH_3$) of the linker (which will be removed) should be constrained to a charge of -1-(-0.3079)=**-0.6921** during the RESP fit.\n",
    "\n",
    "#### Labeled DNA 3'-terminus\n",
    "The 3'-end nucleotide will become an internal residue (DNA charge: -1). The linker will become the new 3'-terminus (DNA charge: -0.36921, i.e. $-PO_2-$ will be retained). For this purpose, the **methoxy cap** ($-O-CH_3$) of the linker (which will be removed) should be constrained to a charge of -1-(-0.6021)=**-0.3079** during the RESP fit.\n",
    "\n",
    "<img src='images/POS_linker.png' width=800>\n",
    "\n",
    "\n",
    "### Rational for linker RESP charge derivation at 3'-end via hydrazide\n",
    "\n",
    "Insertion of a hydrazide with sugar ring closure can only occur in riboses (RNA) because it requires a dialdehyde (O2', O3'). The four RNA bases are parameterized such that the partial charges of the base + C1' + H1' = **0.1160**. The NH2 capping group of the linker (which is a placeholder for the base) + C1' + H1' are therefore constrained to **0.1160**. The charges of C1' and H1' are fixed to those of the respective nucleotide in the Amber force field (e.g. for adenosine: C1'=**0.0394** and H1'=**0.2007**)\n",
    "\n",
    "The methoxy cap (which will be removed) is constrained to -0.3081 such that the remaining fragment will sum up to **-0.6919**.\n",
    "\n",
    "<img src='images/etheno_hydrazide_linker.png' width=800>\n",
    "\n",
    "### Rational for linker RESP charge derivation at internal ethenoadenine / ethenocytosine\n",
    "\n",
    "The amino capping groups of the linker (which will be removed) are constrained to the partial charge of H61+H62 (adenosine/deoxyadenosine) or H41+H42 (cytidine/deoxycytidine) (e.g. for deoxyadenosine 2\\*(-0.4167)= **-0.8334**). Thus for deoxyadenosine the linker will be 0-(-0.8334)=**0.8334** which compensates the missing H61/N62 or H41/N42 in the ethenoadenosine / ethenocytidine."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 3'/5'-end phosphates\n",
    "Acpype requires a residue with integral charge (...,-1,0,1,...). Therefore, we will combine the 3'-end and 5'-end fragments into a dinucleotide (charge: -2) using PyMOL."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 501,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'cmd_gui' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-501-b1111d14b5b5>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;31m# end = {'base':'RU', '5':'RUP', '3':'RUH'}\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     14\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 15\u001b[0;31m \u001b[0mcmd_gui\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreinitialize\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     16\u001b[0m \u001b[0mcmd_gui\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'../fragments/base_linkers/{}.mol2'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'5'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0mcmd_gui\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'../fragments/base_linkers/{}.mol2'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'3'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'cmd_gui' is not defined"
     ]
    }
   ],
   "source": [
    "end = {'base':'DA', '5':'DAP', '3':'DAO'}\n",
    "# end = {'base':'DG', '5':'DGP', '3':'DGO'}\n",
    "# end = {'base':'DC', '5':'DCP', '3':'DCO'}\n",
    "# end = {'base':'DT', '5':'DTP', '3':'DTO'}\n",
    "# end = {'base':'RA', '5':'RAP', '3':'RAO'}\n",
    "# end = {'base':'RG', '5':'RGP', '3':'RGO'}\n",
    "# end = {'base':'RC', '5':'RCP', '3':'RCO'}\n",
    "# end = {'base':'RU', '5':'RUP', '3':'RUO'}\n",
    "\n",
    "# end = {'base':'RA', '5':'RAP', '3':'RAH'}\n",
    "# end = {'base':'RG', '5':'RGP', '3':'RGH'}\n",
    "# end = {'base':'RC', '5':'RCP', '3':'RCH'}\n",
    "# end = {'base':'RU', '5':'RUP', '3':'RUH'}\n",
    "£\n",
    "cmd_gui.reinitialize()\n",
    "cmd_gui.load('../fragments/base_linkers/{}.mol2'.format(end['5']))\n",
    "cmd_gui.load('../fragments/base_linkers/{}.mol2'.format(end['3']))\n",
    "\n",
    "# reassigning residue numbers and segment ids preserves the atom numbering after running through acpype\n",
    "cmd_gui.alter('resn POS and {}'.format(end['5']), 'resi=\"1\"')\n",
    "cmd_gui.alter('resn POS and {}'.format(end['5']), 'segi=\"1\"')\n",
    "cmd_gui.alter('resn {}'.format(end['base']), 'resi=\"2\"')\n",
    "cmd_gui.alter('resn {}'.format(end['base']), 'segi=\"2\"')\n",
    "cmd_gui.alter('(resn POS or resn HYD) and {}'.format(end['3']), 'resi=\"3\"')\n",
    "cmd_gui.alter('(resn POS or resn HYD) and {}'.format(end['3']), 'segi=\"3\"')\n",
    "cmd_gui.remove('{} and resn {}'.format(end['5'], end['base']))\n",
    "cmd_gui.create('{}_{}'.format(end['5'],end['3']), '{} or {}'.format(end['5'],end['3']))\n",
    "cmd_gui.bond('(resn {} or resn HYD) and name P'.format(end['base']), 'resn POS and name O01 and resi 1')\n",
    "cmd_gui.alter('resn POS', 'resn=\"{}\"'.format(end['3']))\n",
    "cmd_gui.alter('resn {} or resn HYD'.format(end['base']), 'resn=\"{}\"'.format(end['3']))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 753,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.pymol_savemol2('../fragments/acpype/{}_{}_ff.mol2'.format(end['5'], end['3']), '{}_{}'.format(end['5'], end['3']), overwrite=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Run **Acpype** on the dinucleotide fragments.\n",
    "\n",
    "```\n",
    "cd ../fragments/acpype/\n",
    "fusion=DAP_DAO\n",
    "fusion=DGP_DGO\n",
    "fusion=DCP_DCO\n",
    "fusion=DTP_DTO\n",
    "fusion=RAP_RAO\n",
    "fusion=RGP_RGO\n",
    "fusion=RCP_RCO\n",
    "fusion=RUP_RUO\n",
    "\n",
    "fusion=RAP_RAH\n",
    "fusion=RGP_RGH\n",
    "fusion=RCP_RCH\n",
    "fusion=RUP_RUH\n",
    "acpype -i \"$fusion\"_ff.mol2 -o gmx -n -1 -a amber -c user\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Read the itp files into the `fd.ff.Molecule` class and the forcefield modification parameters into the `fd.ff.Parameters` class.\n",
    "> The dinucleotides are differentiated by their `subst_id`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 610,
   "metadata": {},
   "outputs": [],
   "source": [
    "moleculetypes = [{'base':'DA', '5':'DAP', '3':'DAO'},\n",
    "       {'base':'DG', '5':'DGP', '3':'DGO'},\n",
    "       {'base':'DC', '5':'DCP', '3':'DCO'},\n",
    "       {'base':'DT', '5':'DTP', '3':'DTO'},\n",
    "       {'base':'RA', '5':'RAP', '3':'RAO'},\n",
    "       {'base':'RG', '5':'RGP', '3':'RGO'},\n",
    "       {'base':'RC', '5':'RCP', '3':'RCO'},\n",
    "       {'base':'RU', '5':'RUP', '3':'RUO'},\n",
    "       {'base':'RU', '5':'RAP', '3':'RAH'},\n",
    "       {'base':'RU', '5':'RGP', '3':'RGH'},\n",
    "       {'base':'RU', '5':'RCP', '3':'RCH'},\n",
    "       {'base':'RU', '5':'RUP', '3':'RUH'}]\n",
    "\n",
    "for end in moleculetypes:\n",
    "    fusion_itp = fd.ff.Molecule.read_molecule('../../../fluordynamics/fragments/acpype/{}_{}_ff.acpype/{}_{}_ff_GMX.itp'.format(end['5'],end['3'],end['5'],end['3']), 'FLUOR-DYNAMICS')\n",
    "    if 'H' not in end['3']:\n",
    "        fusion_itp.change_type('O3\\'', 'OS') # residue is internal not terminal\n",
    "    baselinkers_ff['{}_{}'.format(end['5'],end['3'])] = fd.ff.Parameters.read_frcmod('../../../fluordynamics/fragments/acpype/{}_{}_ff.acpype/{}_{}_ff_AC.frcmod'.format(end['5'],end['3'],end['5'],end['3']), fusion_itp.atomtypes_molecule)\n",
    "    amberdyes_ff.append(baselinkers_ff['{}_{}'.format(end['5'],end['3'])])\n",
    "        \n",
    "    ff_mol2 = PandasMol2().read_mol2('../../../fluordynamics/fragments/acpype/{}_{}_ff.mol2'.format(end['5'],end['3']))\n",
    "    atoms5 = fusion_itp.atoms[(ff_mol2.df['subst_id']==1) | (ff_mol2.df['subst_id']==2)]\n",
    "    atoms3 = fusion_itp.atoms[(ff_mol2.df['subst_id']==2) | (ff_mol2.df['subst_id']==3)]\n",
    "    bonds5 = fusion_itp.bonds[fusion_itp.bonds['i'].isin(atoms5['nr']) & fusion_itp.bonds['j'].isin(atoms5['nr'])]\n",
    "    bonds3 = fusion_itp.bonds[fusion_itp.bonds['i'].isin(atoms3['nr']) & fusion_itp.bonds['j'].isin(atoms3['nr'])]\n",
    "    impropers5 = fusion_itp.impropers[fusion_itp.impropers['i'].isin(atoms5['nr']) & fusion_itp.impropers['j'].isin(atoms5['nr']) & fusion_itp.impropers['k'].isin(atoms5['nr']) & fusion_itp.impropers['l'].isin(atoms5['nr'])]\n",
    "    impropers3 = fusion_itp.impropers[fusion_itp.impropers['i'].isin(atoms3['nr']) & fusion_itp.impropers['j'].isin(atoms3['nr']) & fusion_itp.impropers['k'].isin(atoms3['nr']) & fusion_itp.impropers['l'].isin(atoms3['nr'])]\n",
    "    \n",
    "    baselinkers_itp[end['5']] = fd.ff.Molecule(end['5'], atoms5, bonds5, None, None, impropers5)\n",
    "    baselinkers_itp[end['3']] = fd.ff.Molecule(end['3'], atoms3, bonds3, None, None, impropers3)\n",
    "    for a in ['O98', 'C16', 'C17', 'H95', 'H96', 'H97']:\n",
    "        baselinkers_itp[end['5']].remove_atom(a)\n",
    "        baselinkers_itp[end['3']].remove_atom(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Ethenoadenine and ethenocytosine"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```\n",
    "cd ../fragments/acpype\n",
    "\n",
    "base_linker=RAE\n",
    "base=RA\n",
    "\n",
    "base_linker=RCE\n",
    "base=RC\n",
    "\n",
    "base_linker=DAE\n",
    "base=DA\n",
    "\n",
    "base_linker=DCE\n",
    "base=DC\n",
    "\n",
    "linker=ETH\n",
    "filename=../base_linkers/\"$base_linker\".mol2\n",
    "sed \"s/${base}/${base_linker}/g\" \"$filename\" | sed \"s/${linker}/${base_linker}/g\" > \"$base_linker\"_ff.mol2\n",
    "acpype -i \"$base_linker\"_ff.mol2 -o gmx -n -1 -a amber -c user\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 611,
   "metadata": {},
   "outputs": [],
   "source": [
    "moleculetypes = ['RAE', 'RCE', 'DAE', 'DCE']\n",
    "\n",
    "for mol in moleculetypes:\n",
    "    baselinkers_itp[mol] = fd.ff.Molecule.read_molecule('../../../fluordynamics/fragments/acpype/{}_ff.acpype/{}_ff_GMX.itp'.format(mol,mol), 'FLUOR-DYNAMICS')\n",
    "    baselinkers_itp[mol].change_type('O3\\'', 'OS') # residue is internal not terminal\n",
    "    for a in ['O98', 'C16', 'C17', 'H95', 'H96', 'H97']:\n",
    "        baselinkers_itp[mol].remove_atom(a)\n",
    "    baselinkers_ff[mol] = fd.ff.Parameters.read_frcmod('../../../fluordynamics/fragments/acpype/{}_ff.acpype/{}_ff_AC.frcmod'.format(mol,mol), baselinkers_itp[mol].atomtypes_molecule)\n",
    "    amberdyes_ff.append(baselinkers_ff[mol])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Define the atoms for the specialbonds."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 612,
   "metadata": {},
   "outputs": [],
   "source": [
    "atoms_amberdyes = {'bondtypes' : [['ng', 'cg']],\n",
    "                   'angletypes': [['c3g', 'ng', 'cg'],\n",
    "                                  ['hng', 'ng', 'cg'],\n",
    "                                  ['ng', 'cg', 'og'],\n",
    "                                  ['ng', 'cg', 'c3g'],\n",
    "                                  ['C', 'N', 'NT']],\n",
    "                   'propertypes' : [['c3g', 'c3g', 'cg', 'ng'],\n",
    "                                    ['hcg', 'c3g', 'cg', 'ng'],\n",
    "                                    ['c3g', 'cg', 'ng', 'hng'],\n",
    "                                    ['og', 'cg', 'ng', 'hng'],\n",
    "                                    ['c3g', 'cg', 'ng', 'c3g'],\n",
    "                                    ['og', 'cg', 'ng', 'c3g'],\n",
    "                                    ['C', 'N', 'NT', 'CT'],\n",
    "                                    ['X', 'C', 'N', 'X'],\n",
    "                                    ['X', 'C', 'N', 'X']],\n",
    "                   'impropertypes': [['C', 'CB', 'CB', 'NB'],\n",
    "                                     ['CB', 'N*', 'CB', 'NC']]\n",
    "                  }\n",
    "\n",
    "atoms_linker = {'bondtypes': [['N', 'cg']],\n",
    "                'angletypes': [['CT', 'N', 'cg'],\n",
    "                               ['H', 'N', 'cg'],\n",
    "                               ['N', 'cg', 'og'],\n",
    "                               ['N', 'cg', 'c3g'],\n",
    "                               ['cg', 'N', 'NT']],\n",
    "                'propertypes': [['c3g', 'c3g', 'cg', 'N'],\n",
    "                                ['hcg', 'c3g', 'cg', 'N'],\n",
    "                                ['c3g', 'cg', 'N', 'H'],\n",
    "                                ['og', 'cg', 'N', 'H'],\n",
    "                                ['c3g', 'cg', 'N', 'CT'],\n",
    "                                ['og', 'cg', 'N', 'CT'],\n",
    "                                ['cg', 'N', 'NT', 'CT'],\n",
    "                                ['c3g', 'cg', 'N', 'NT'],\n",
    "                                ['og', 'cg', 'N', 'NT']],\n",
    "               'impropertypes': [['CB', 'CB', 'C', 'NB'],\n",
    "                                 ['NC', 'CB', 'CB', 'N*']]\n",
    "               }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 613,
   "metadata": {},
   "outputs": [],
   "source": [
    "atoms_amberdyes2 = {'propertypes' : [['X', 'C', 'N', 'X'],\n",
    "                                    ['X', 'C', 'N', 'X']]\n",
    "                   }\n",
    "atoms_linker2 = {'propertypes' : [['c3g', 'cg', 'N', 'NT'],\n",
    "                                  ['og', 'cg', 'N', 'NT']]\n",
    "                }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 614,
   "metadata": {},
   "outputs": [],
   "source": [
    "specialbond_ff = fd.ff.Parameters.read_specialbond(amberdyes_ff, atoms_amberdyes, atoms_linker)\n",
    "specialbond2_ff = fd.ff.Parameters.read_specialbond(aber14sb_ff, atoms_amberdyes2, atoms_linker2, 'AMBER14sb')\n",
    "\n",
    "amberdyes_ff.append(specialbond_ff)\n",
    "amberdyes_ff.append(specialbond2_ff)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Write new **ffnonbonded.itp** and **ffbonded.itp** files of the combined forcefield (ff14sb, amberdyes_ff, baselinkers_ff and specialbond_ff) into a directory fluordyes/."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 615,
   "metadata": {},
   "outputs": [],
   "source": [
    "amberdyes_ff.add2ff('ff14sb', '../../../fluordynamics/forcefields/fluordyes/')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Export a residue topology (**rtp**) file with the new base-linkers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 616,
   "metadata": {},
   "outputs": [],
   "source": [
    "fd.ff.write_rtp('../../../fluordynamics/forcefields/fluordyes/fluordyes.rtp', [baselinkers_itp[mol] for mol in baselinkers_itp.keys()])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Update the **residuetypes.dat** file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "45 new entries in residuetypes.dat\n"
     ]
    }
   ],
   "source": [
    "i = 0\n",
    "for resi in ['DAO', 'DGO', 'DCO', 'DTO', 'DAP', 'DGP', 'DCP', 'DTP', 'DTM', 'RUM', 'DAE', 'DCE']:\n",
    "    if i == 0:\n",
    "        fd.ff.update_residuetypes('{} DNA'.format(resi), '../../../fluordynamics/forcefields/amberdyes/residuetypes_amberdyes.dat', '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', overwrite=True)\n",
    "    else:\n",
    "        fd.ff.update_residuetypes('{} DNA'.format(resi), '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', overwrite=True)\n",
    "    i += 1\n",
    "    \n",
    "for resi in ['RAO', 'RGO', 'RCO', 'RUO', 'RAP', 'RGP', 'RCP', 'RUP', 'RAH', 'RGH', 'RCH', 'RUH', 'RAE', 'RCE']:\n",
    "    fd.ff.update_residuetypes('{} RNA'.format(resi), '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', overwrite=True)\n",
    "    i += 1\n",
    "    \n",
    "for name,resi in dyes:\n",
    "    fd.ff.update_residuetypes('{} RNA'.format(resi), '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', '../../../fluordynamics/forcefields/fluordyes/residuetypes.dat', overwrite=True)\n",
    "    i += 1\n",
    "print('{} new entries in residuetypes.dat'.format(i))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Update the **specbond.dat** file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "658 new entries in specbond.dat\n"
     ]
    }
   ],
   "source": [
    "i = 0\n",
    "for name, resi1 in dyes:\n",
    "    for resi2 in ['DAO', 'DGO', 'DCO', 'DTO', 'DAP', 'DGP', 'DCP', 'DTP', \n",
    "                  'RAO', 'RGO', 'RCO', 'RUO', 'RAP', 'RGP', 'RCP', 'RUP', \n",
    "                  'DTM', 'RUM', 'RAE', 'RCE', 'DAE', 'DCE']:\n",
    "        if i == 0:\n",
    "            fd.ff.update_specbond('{} C99 1 {} N99 1 0.132 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/amberdyes/specbond_amberdyes.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        else:\n",
    "            fd.ff.update_specbond('{} C99 1 {} N99 1 0.132 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "    for resi2 in ['RAH', 'RGH', 'RCH', 'RUH']:\n",
    "        fd.ff.update_specbond('{} C99 1 {} N99 1 0.155 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "        \n",
    "for resi1 in ['DA', 'DG', 'DC', 'DT']:\n",
    "    for resi2 in ['DAO', 'DGO', 'DCO', 'DTO']:\n",
    "        fd.ff.update_specbond(' {} O3\\' 1 {} P 1 0.155 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "    for resi2 in ['DAP', 'DGP', 'DCP', 'DTP']:\n",
    "        fd.ff.update_specbond('{} O3\\' 1  {} P 1 0.155 {} {}'.format(resi2, resi1, resi2, resi1), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "    for resi2 in ['DTM', 'DAE', 'DCE']:\n",
    "        fd.ff.update_specbond('{} O3\\' 1  {} P 1 0.155 {} {}'.format(resi2, resi1, resi2, resi1), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        fd.ff.update_specbond(' {} O3\\' 1 {} P 1 0.155 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)    \n",
    "        i += 1\n",
    "        \n",
    "for resi1 in ['RA', 'RG', 'RC', 'RU', 'A', 'G', 'C', 'U']:\n",
    "    for resi2 in ['RAO', 'RGO', 'RCO', 'RUO', 'RAH', 'RGH', 'RCH', 'RUH']:\n",
    "        fd.ff.update_specbond(' {} O3\\' 1 {} P 1 0.155 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "    for resi2 in ['RAP', 'RGP', 'RCP', 'RUP']:\n",
    "        fd.ff.update_specbond('{} O3\\' 1  {} P 1 0.155 {} {}'.format(resi2, resi1, resi2, resi1), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        i += 1\n",
    "    for resi2 in ['RUM', 'RAE', 'RCE']:\n",
    "        fd.ff.update_specbond('{} O3\\' 1  {} P 1 0.155 {} {}'.format(resi2, resi1, resi2, resi1), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)\n",
    "        fd.ff.update_specbond(' {} O3\\' 1 {} P 1 0.155 {} {}'.format(resi1, resi2, resi1, resi2), '../../../fluordynamics/forcefields/fluordyes/specbond.dat', '../../../fluordynamics/forcefields/fluordyes/specbond.dat', overwrite=True)    \n",
    "        i += 1\n",
    "print('{} new entries in specbond.dat'.format(i))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
